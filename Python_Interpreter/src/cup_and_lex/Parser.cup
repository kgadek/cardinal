
package parser;

import python_program.*;
import java.util.LinkedList;
import java.util.List;
import java.util.Collections;

import java_cup.runtime.*;

parser code
{:
:}

action code
{:
:}


terminal		PRINT,
				PLUS,
				MINUS,
				UMINUS,
				MULT,
				DIV,
				POW,
				MOD,
				LEFTPARENTHESE,
				RIGHTPARENTHESE,
				INPUT,
				INTEGER,
				COMMA,
				NOT,
				LESS,
				GREATER,
				EQUAL,
				GREATEROREQUAL,
				LESSOREQUAL,
				NOTEQUAL,
				OR,
				AND,
				TRUE,
				FALSE,
				IF,
				ELSE,
				FLOAT,
				COLON,
				IDENTIFIER,
				NEWLINE,
				PASS,
				ASSIGN,
				WHILE,
				SEMICOLON,
				INDENT,
				DEDENT,
				LEFTSQUAREBRACKET,
				RIGHTSQUAREBRACKET,
				LEFTCURLYBRACKET,
				RIGHTCURLYBRACKET,
				IS,
				LAMBDA,
				DEF,
				RETURN,
				FULLSTOP,
				CLASS;

non terminal	program,
				module,
				simple_statement,
				simple_statement_list,
				expression,
				expression_comma_list,
				unary_op,
				binary_op,
				compound_statement,
				stmt_list,
				simple_stmt_semicolon_list,
				statement,
				suite,
				statement_list,
				statement_newline_list,
				key_datum,
				key_datum_comma_list,
				subscription,
				target,
				identifier_comma_list,
				expression_list,
				arithmetic_expression;
				
				
/* Precedences */
precedence left LAMBDA;
precedence left IF, ELSE;
precedence left ASSIGN;
precedence left FULLSTOP;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left LESS, GREATER, LESSOREQUAL, GREATEROREQUAL, EQUAL, NOTEQUAL, IS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left UMINUS;
precedence left POW;
precedence left LEFTSQUAREBRACKET, RIGHTSQUAREBRACKET, LEFTCURLYBRACKET, RIGHTCURLYBRACKET, LEFTPARENTHESE, RIGHTPARENTHESE;

program						::=	module:list
								{: 	Collections.reverse((List<SimpleStatement>)list);
									RESULT = new Program((List<SimpleStatement>)list);
								:};

module						::= simple_statement:stmt simple_statement_list:list
									{: ((List<SimpleStatement>)list).add((SimpleStatement)stmt);
										RESULT = list;
									:}
								|
								statement_newline_list:list							//#3
								{: RESULT = list; :};

statement_newline_list		::=	NEWLINE statement_newline_list:list
								{:	RESULT = list; :} 
								|
								statement:stmt statement_newline_list:list			//#5
								{:	((List<SimpleStatement>)list).addAll((List<SimpleStatement>)stmt);
									RESULT = list;
								:}
								|
								/*epsilon*/											//#6
								{: RESULT = new LinkedList<SimpleStatement>(); :}; 

simple_statement_list		::= simple_statement:stmt simple_statement_list:list
									{: ((List<SimpleStatement>)list).add((SimpleStatement)stmt);
										RESULT = list;
									:}
								| 
								/* epsilon */
									{: RESULT = new LinkedList<SimpleStatement>(); :};
							
simple_statement			::= PRINT expression:expr expression_comma_list:list			//#9
									{: ((List<Expression>)list).add((Expression)expr); 
										RESULT = new PrintStatement((List<Expression>)list); 
									:}
								|
								PASS
								|
								IDENTIFIER ASSIGN expression
								|
								expression
								|
								target ASSIGN expression
								|
								RETURN expression;

expression_comma_list		::= COMMA expression:expr expression_comma_list:list
									{: ((List<Expression>)list).add((Expression)expr); 
										RESULT = list;
									:}
								|
								/*epsilon*/									//#16
									{: RESULT = new LinkedList<Expression>(); :};

unary_op					::= NOT
									{: RESULT = UnaryOperators.not; :};
							
binary_op					::= PLUS
									{: RESULT = BinaryOperators.add; :}		%prec PLUS
								|
								MINUS
									{: RESULT = BinaryOperators.sub; :}		%prec MINUS
								|											//#22
								MULT
									{: RESULT = BinaryOperators.mult; :}	%prec MULT
								|
								DIV											//#23
									{: RESULT = BinaryOperators.div; :}		%prec DIV
								|
								MOD
									{: RESULT = BinaryOperators.mod; :}		%prec MOD
								|
								POW
									{: RESULT = BinaryOperators.pow; :}		%prec POW
								|
								LESS
									{: RESULT = BinaryOperators.less; :}
								|
								GREATER
									{: RESULT = BinaryOperators.greater; :}
								|
								EQUAL
									{: RESULT = BinaryOperators.equal; :}
								|
								GREATEROREQUAL
									{: RESULT = BinaryOperators.greaterorequal; :}
								|
								LESSOREQUAL
									{: RESULT = BinaryOperators.lessorequal; :}
								|
								NOTEQUAL
									{: RESULT = BinaryOperators.notequal; :}
								|
								OR
									{: RESULT = BinaryOperators.or; :}
								|
								AND
									{: RESULT = BinaryOperators.and; :};
				
arithmetic_expression		::= INTEGER:value												
									{: RESULT = new IntegerExpression((String)value); :}
								|
								MINUS expression:expr									
									{: RESULT = new UnaryExpression(UnaryOperators.sub, (Expression) expr); :} %prec UMINUS
								|
								PLUS expression:expr									
									{: RESULT = new UnaryExpression(UnaryOperators.add, (Expression) expr); :} %prec UMINUS
								|
								expression:expr1 PLUS expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.add, (Expression) expr2); :}
								|
								expression:expr1 MINUS expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.sub, (Expression) expr2); :}
								|
								expression:expr1 MULT expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.mult, (Expression) expr2); :}
								|
								expression:expr1 DIV expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.div, (Expression) expr2); :}
								|
								expression:expr1 MOD expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.mod, (Expression) expr2); :}
								|
								expression:expr1 POW expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.pow, (Expression) expr2); :};
								
expression					::= arithmetic_expression:expr
									{: RESULT = expr; :}
								|
								LEFTPARENTHESE expression:expr RIGHTPARENTHESE
									{: RESULT = new ParenthesesExpression((Expression)expr); :}
								|
								INPUT LEFTPARENTHESE RIGHTPARENTHESE
									{: RESULT = new InputExpression(); :}
								|
								FLOAT:value
									{: RESULT = new FloatExpression(((String)value)); :}
								|
								TRUE
									{: RESULT = new TrueExpression(); :}
								|
								FALSE
									{: RESULT = new FalseExpression(); :}
								|
								IDENTIFIER
								|
								LEFTSQUAREBRACKET expression expression_comma_list RIGHTSQUAREBRACKET
								|
								LEFTCURLYBRACKET key_datum key_datum_comma_list RIGHTCURLYBRACKET
								|
								subscription
								|
								expression IS expression
								|
								expression LEFTPARENTHESE RIGHTPARENTHESE
								|
								expression LEFTPARENTHESE expression expression_comma_list RIGHTPARENTHESE
								|
								LAMBDA COLON expression
								|
								LAMBDA IDENTIFIER identifier_comma_list COLON expression
								|
								expression FULLSTOP IDENTIFIER;
				
compound_statement			::= IF expression COLON suite ELSE COLON suite
								|
								IF expression COLON suite
								|
								WHILE expression COLON suite
								|
								DEF IDENTIFIER LEFTPARENTHESE RIGHTPARENTHESE COLON suite
								|
								DEF IDENTIFIER LEFTPARENTHESE IDENTIFIER identifier_comma_list RIGHTPARENTHESE COLON suite
								|
								CLASS IDENTIFIER COLON suite
								|
								CLASS IDENTIFIER LEFTPARENTHESE expression_list RIGHTPARENTHESE COLON suite;
								
stmt_list					::= simple_statement:stmt simple_stmt_semicolon_list:list			//#59
								{: ((List<SimpleStatement>)list).add((SimpleStatement)stmt); 
									RESULT = list;
								:};

simple_stmt_semicolon_list	::= SEMICOLON simple_statement:stmt simple_stmt_semicolon_list:list
								{: ((List<SimpleStatement>)list).add((SimpleStatement)stmt); 
									RESULT = list;
								:}
								|
								/*epsilon*/											//#61
								{: RESULT = new LinkedList<SimpleStatement>(); :};
						
statement					::= stmt_list:list NEWLINE								//#62
								{: RESULT = list; :}
								|
								compound_statement;
								
								
suite						::= stmt_list NEWLINE
								|
								NEWLINE INDENT statement statement_list DEDENT;
								
statement_list				::= statement statement_list
								|
								/*epsilon*/;

key_datum					::= expression COLON expression;

key_datum_comma_list		::= COMMA key_datum key_datum_comma_list
								|
								/*epsilon*/;

subscription				::= expression LEFTSQUAREBRACKET expression RIGHTSQUAREBRACKET;

target						::= subscription
								|
								expression FULLSTOP IDENTIFIER;

identifier_comma_list		::= COMMA IDENTIFIER identifier_comma_list
								|
								/*epsilon*/;
								
expression_list				::= expression expression_comma_list;